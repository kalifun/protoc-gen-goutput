package plugin

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	pb "github.com/kalifun/protoc-gen-goutput/descriptor"
	"github.com/kalifun/protoc-gen-goutput/generator"
	op "github.com/kalifun/protoc-gen-goutput/goutput"
)

type goutput struct {
	gen *generator.Generator
}

func NewPlugin() generator.Plugin {
	return &goutput{}
}

// Name identifies the plugin.
func (gp *goutput) Name() string {
	return "goutput"
}

// Init is called once after data structures are built but before
// code generation begins.
func (gp *goutput) Init(g *generator.Generator) {
	gp.gen = g
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (gp *goutput) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}

	for i, service := range file.FileDescriptorProto.Service {
		gp.generateService(file, service, i)
	}
}

// GenerateImports produces the import declarations for this file.
// It is called after Generate.
func (gp *goutput) GenerateImports(file *generator.FileDescriptor) {

}

// P forwards to g.gen.P.
func (gp *goutput) P(args ...interface{}) { gp.gen.P(args...) }

func (gp *goutput) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	v, err := proto.GetExtension(service.GetOptions(), op.E_Api)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(v)
}

func init() {
	generator.RegisterPlugin(NewPlugin())
}
